package se.lnu.prosses.jimpleProcessor;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.xmlpull.v1.XmlPullParserException;

import se.lnu.prosses.Benchmarks.BenchmarkExperimentConfig;
import se.lnu.prosses.general.Constants;
import se.lnu.prosses.general.SynthesisConfiguratons;
import se.lnu.prosses.general.Utils;
import se.lnu.prosses.general.XMLSecstubsParser;
import se.lnu.prosses.general.XMLSourceSinkParser;
import soot.Scene;
import soot.SootClass;
import soot.SootMethod;
import soot.Type;
import soot.Value;
import soot.jimple.ClassConstant;
import soot.jimple.FieldRef;
import soot.jimple.StaticFieldRef;
import soot.jimple.internal.AbstractBinopExpr;
import soot.jimple.internal.JAddExpr;
import soot.jimple.internal.JAndExpr;
import soot.jimple.internal.JArrayRef;
import soot.jimple.internal.JCastExpr;
import soot.jimple.internal.JCmpExpr;
import soot.jimple.internal.JCmpgExpr;
import soot.jimple.internal.JCmplExpr;
import soot.jimple.internal.JDivExpr;
import soot.jimple.internal.JEqExpr;
import soot.jimple.internal.JGeExpr;
import soot.jimple.internal.JGtExpr;
import soot.jimple.internal.JInstanceOfExpr;
import soot.jimple.internal.JLeExpr;
import soot.jimple.internal.JLengthExpr;
import soot.jimple.internal.JLtExpr;
import soot.jimple.internal.JMulExpr;
import soot.jimple.internal.JNeExpr;
import soot.jimple.internal.JNegExpr;
import soot.jimple.internal.JNewArrayExpr;
import soot.jimple.internal.JNewMultiArrayExpr;
import soot.jimple.internal.JOrExpr;
import soot.jimple.internal.JRemExpr;
import soot.jimple.internal.JShlExpr;
import soot.jimple.internal.JShrExpr;
import soot.jimple.internal.JSubExpr;
import soot.jimple.internal.JUshrExpr;
import soot.jimple.internal.JXorExpr;

public class JimpleProjectHelper {
	public SourceSinkHelper sourceSinkHelper= new SourceSinkHelper();
	public Hashtable<String, ArrayList<SecuritySignature>> securitySignatures = new Hashtable<String, ArrayList<SecuritySignature>>();
	public SynthesisConfiguratons configurations = new SynthesisConfiguratons();
	private LinkedHashMap<SootMethod, ArrayList<String>> librarySecurityAssumptions = new LinkedHashMap<SootMethod, ArrayList<String>> ();
	public String staticFileds = "";
	public List<SootMethod> methodsWithNoSecSignature = new ArrayList<SootMethod>();
	public List<SootMethod> methodsWithAutoGeneratedSecSignature = new ArrayList<SootMethod>();

	private List<String> errLog = new ArrayList<> ();
	public void writeErrLog () {
		Utils.writeTextFile (configurations.outputPath + File.separator +
				     Constants.errLogFile, errLog);
	}
	public void logErr (String err) {
		errLog.add (err);
		Utils.logErr (getClass (), err);
	}

	public class SecuritySignature {
		public String className;
		public String method;
		public String returnType;
		public String[] argsType = new String[] {};
		public List<String> secSignature = new ArrayList<String>();
		public boolean isStatic = false;


		public boolean extractSecuritySigntaure(String line) {
			String[] elements = line.split("\\{");
			if(extractMethodSignature(elements[0]))
				try {
					isStatic = line.trim().startsWith("static ");
					extractSecstubs(elements[1].split("\\}")[0].replaceAll("\\{", "").replaceAll("\\}", ""));
				} catch (StringIndexOutOfBoundsException|java.lang.ArrayIndexOutOfBoundsException ex) {
					Utils.log(this.getClass(),
							"This line of secsum file does not follow a correct method signature: \n 		" + line);
					return false;
				}
			return true;
		}

		private void extractSecstubs(String signature) {
			Matcher m = Pattern.compile("[^;]*;").matcher(signature+";");
			while (m.find()) {
				String stub = m.group().trim();
				stub = stub.replaceAll(";", "").trim();
				if(isStatic && stub.contains(".*")) {
					Utils.logErr(getClass(), className + ":" + method + " is static but its security siganture returns/uses .*. Replaced with return *.");
					stub = stub.replaceAll("\\.\\*", "\\*");
				}
				if(!stub.equals("") && !secSignature.contains(stub))
					secSignature.add(stub);
			}
		}

		String secstubsToString() {
			String res = "";
			for (String tmp: this.secSignature)
				res += tmp + ";";
			return res;
		}

		public boolean extractMethodSignature(String signature) {

			Matcher m = Pattern.compile("\\S+:\\S+\\(").matcher(signature);
			try {
				if (m.find()) {
					String packAndMethodName = m.group().substring(0, m.group().length() - 1);
					className = packAndMethodName.split(":")[0];
					method = packAndMethodName.split(":")[1];
				} else {
					className = signature.substring(0, signature.indexOf('('));
					String[] classNameX = className.split (" ");
					className = classNameX[classNameX.length-1];
					method = "";
				}

				m = Pattern.compile("\\(.*\\)").matcher(signature);
				if (m.find()) {
					String tmp = m.group();
					tmp = tmp.substring(1, tmp.length() - 1);
					if (!tmp.equals(""))
						argsType = tmp.replaceAll(" ", "").split(",");
				}

				if (signature.contains(":")) {
					m = Pattern.compile("(\\S)*\\s*").matcher(signature.replaceAll("static ", "").trim());
					if (m.find())
						returnType = m.group().trim();
				}
			} catch (StringIndexOutOfBoundsException ex) {
				Utils.log(this.getClass(),
						"This line of secsum file does not follow a correct method signature: \n 		" + signature);
				return false;
			} catch (java.lang.ArrayIndexOutOfBoundsException ex) {
				Utils.log(this.getClass(),
						" This line of secsum file does not follow a correct method signature: \n 		" + signature);
				return false;

			}
			return true;
		}

		public boolean matches(SootMethod method2){
			if (method2.getParameterCount() != argsType.length)
				return false;
			TypeProcessor typeProcessor = new TypeProcessor(configurations.allowInconsistentTypes);
			try {
				if (!(method2.getDeclaringClass().toString().equals(className) || typeProcessor
						.isSubTypeSuperType(method2.getDeclaringClass(), Scene.v().getSootClass(className)))) {
					return false;
				}
				if (argsType != null)
					for (int i = 0; i < argsType.length; i++)
						if (!(argsType[i].equals(method2.getParameterType(i).toString()) || typeProcessor
								.isSubTypeSuperType(Scene.v().getSootClass(method2.getParameterType(i).toString()),
										Scene.v().getSootClass(argsType[i])))) {
							return false;
						}
				if (returnType!=null && (!(this.returnType.equals(method2.getReturnType().toString()) || typeProcessor.isSubTypeSuperType(
						Scene.v().getSootClass(method2.getReturnType().toString()), Scene.v().getSootClass(returnType)))) ) {
					return false;
				}
				if (returnType==null &&!method2.isConstructor()) {
					return false;
				}
			} catch (TransformationException e) {
				Utils.log(getClass(), "Warning: Runtime error with checking the inheritance relations while checking security signatures ");
				return false;
			}
			return true;
		}

		public String header() {
			String argsTypesDesc = "", separator = "";
			if (argsType != null)
				for (String arg : argsType) {
					argsTypesDesc += separator + arg;
					separator = ",";
				}

			return (isStatic? "static " : "") +
				(returnType!=null? returnType + " " : "") +
				(className + (("".equals (method)) ? "" : (":" + method))) +
				"(" + argsTypesDesc + ")";
		}

		@Override
		public String toString() {
			return this.header () + "{" + secstubsToString() + "}\n";
		}
	}

	public static String escapeTypeName(String type) {
		return type.toString().replaceAll("-", "");
	}

	public static String escapeTypeName(Type type) {
		return type.toString().replaceAll("-", "");
	}

	public JimpleProjectHelper(SynthesisConfiguratons settings1) {
		configurations = settings1;
	}

	public JimpleProjectHelper() {
		// TODO Auto-generated constructor stub
	}

	public void analyzeEntryPoints() throws TransformationException {
		TypeProcessor typeProcessor = new TypeProcessor(configurations.allowInconsistentTypes);
		for (SootMethod entryPoint : Scene.v().getEntryPoints())
			analyzeSingleEntrypoint(SootUtilities.getClassName(entryPoint.getDeclaringClass()), entryPoint,
					typeProcessor, sourceSinkHelper);
		typeProcessor.writeTypesClassesFile(configurations.outputPath);
		// typeProcessor.writeTypeHierarchyDotFile(configurations.outputPath);
	}

	public void analyzeSingleEntrypoint(String className, SootMethod entryPoint, TypeProcessor typeProcessor, SourceSinkHelper sourceSinkHelper) throws TransformationException {
		SymmariesHelper scsgHelper = new SymmariesHelper(this, configurations, typeProcessor,sourceSinkHelper);
		scsgHelper.processMethod(entryPoint, SootUtilities.getClassName(entryPoint.getDeclaringClass()));
		generateOutputFiles(scsgHelper);
		// return scsgHelper.typeProcessor;
	}

	public boolean constructSymmariesInputFromAPKFiles(String apkFile) {
		try {
			if(configurations.generateJimple)
				Utils.remakeDirectory(configurations.outputPath + java.io.File.separator + "Jimple");
			if(configurations.generateCfg)
				Utils.remakeDirectory(configurations.outputPath + java.io.File.separator + "CFG");
			Utils.remakeDirectory(configurations.outputPath + java.io.File.separator + "Meth");
			Utils.log(this.getClass(), "Soot: Loading " + apkFile);
			SootInit.initSootForApk(configurations.requiredClassesPaths, apkFile, configurations.xmlSourcesAndSinks,
					configurations.callbacks);
			analyzeEntryPoints();
			return true;
		} catch (IOException e) {
			Utils.logErr(getClass(), "Could not create a dirctory in " + configurations.outputPath);
			//e.printStackTrace();
		} catch (XmlPullParserException e) {
			Utils.logErr(getClass(), "Ill-formatted xml file ");
			//e.printStackTrace();
		} catch (TransformationException e) {
			Utils.logErr(getClass(), "Aborted Processing the Application due to " + e.getLocalizedMessage());
		}
		return false;
	}

	public boolean constructSymmariesInputFromClassFiles(String className, String methodName) {
		if(loadApplication()) {
			//		TypeProcessor typeProcessor = ;
			SymmariesHelper symmariesHelper = new SymmariesHelper(this, configurations, new TypeProcessor(configurations.allowInconsistentTypes), sourceSinkHelper);
			try {
				processApplication(className, methodName, symmariesHelper);
				generateOutputFiles(symmariesHelper);
				symmariesHelper.typeProcessor.writeTypesClassesFile(configurations.outputPath);
				// symmariesHelper.typeProcessor.writeTypeHierarchyDotFile(configurations.outputPath);
				return true;
			}
			catch (TransformationException e) {
				Utils.logErr(getClass(), "Aborted Processing the Application due to " + e.getLocalizedMessage());
				return false;
			}
		} else
			return false;
	}

	private void processApplication(String className, String methodName, SymmariesHelper symmariesHelper) throws TransformationException {
		{
			if (methodName == null) {
				// it first loads all the calsses again
				for (SootClass sootClass : Scene.v().getApplicationClasses())
					Scene.v().loadClassAndSupport(sootClass.getName());
				Scene.v().loadNecessaryClasses();
				SootClass[] applicationClasses = new SootClass[] {};
				applicationClasses = Scene.v().getApplicationClasses().toArray(applicationClasses);
				for (SootClass sootClass : applicationClasses) {// Scene.v().getApplicationClasses()) {
					for (SootMethod entryPoint : sootClass.getMethods()) {
						if (!symmariesHelper.processedMethods.contains(getMethodUniqueName(entryPoint, sootClass.getName()))) {
							//	Utils.log(this.getClass(), "Processing the entry point " + entryPoint.getDeclaringClass() + "."
							//			+ entryPoint.getName());
							symmariesHelper.processMethod(entryPoint,
									SootUtilities.getClassName(entryPoint.getDeclaringClass()));
						}
					}
				}
			}
			else
				symmariesHelper.processMethod(Scene.v().getMethod(methodName), className);
		}
	}

	private boolean loadApplication() {
		if (configurations.clearOldGeneratedfiles || !new File(configurations.outputPath+ java.io.File.separator + "/CFG").exists()
				|| !new File(configurations.outputPath+ java.io.File.separator + "Jimple").exists()
				|| !new File(configurations.outputPath+ java.io.File.separator + "Meth").exists())
			try {
				if(configurations.generateJimple)
					Utils.remakeDirectory(configurations.outputPath + java.io.File.separator + "Jimple");
				if(configurations.generateCfg)
					Utils.remakeDirectory(configurations.outputPath + java.io.File.separator + "CFG");
				//Utils.remakeDirectory(configurations.outputPath + java.io.File.separator + "Meth");
				if(! new File(configurations.outputPath + java.io.File.separator + "Meth").exists())
					new File(configurations.outputPath + java.io.File.separator + "Meth").mkdirs();
			} catch (IOException e) {
				Utils.log(this.getClass(), "The  path " + configurations.outputPath + " does not exist!\n");
				return false;
			}
		try {
			SootInit.initSootForJavaClasses(configurations.inputPath,
							configurations.requiredClassesPaths,
							configurations.enableSootOptimizations);
		}
		catch(java.lang.RuntimeException ex) {
			Utils.logErr(getClass(), "Soot could not load the application successfully! ");
			ex.printStackTrace();
			return false;
		}
		return true;
	}

	public String escapeMethodName(String name) {
		return name.replaceAll("<", "").replaceAll(">", "").replaceAll("-", "");
	}

	// public String getUniqueName(MethodInvocation methodInvocation) {

	// return
	// methodInvocation.resolveMethodBinding().getDeclaringClass().getQualifiedName()
	// + methodInvocation.getName();
	// }

	public void extractSinkAndSources() {
		/*		if(configurations.sourcesAndSinks==null) {
			Utils.log(getClass(), "The source/sink file (in text format) is missing.");
			return;
		}

		File file = new File(configurations.sourcesAndSinks);
		if(!file.exists()){
			Utils.log(getClass(), "The source/sink file (in text format) " + configurations.sourcesAndSinks + " does not exist!");
			return;
		}
		BufferedReader br;
		try {
			br = new BufferedReader(new FileReader(file));
			String line = br.readLine();
			while (line != null) {
				String[] elements = line.split("->");
				if (!line.equals("")) {
					String methodPackageName = elements[0].split(":")[0].replaceAll("<", "") + "_"
							+ elements[0].split(":")[1].trim().split(" ")[1];
					methodPackageName = methodPackageName.substring(0, methodPackageName.indexOf("("));
					// java.net.URLConnection: java.io.InputStream getInputStream()
					if (elements[1].contains("SINK"))
						sourceSinkHelper.sinkMethods.add(methodPackageName);
					else
						sourceSinkHelper.sourceMethods.add(methodPackageName);
					// Utils.log(this.getClass(),methodPackageName.trim());
				}
				line = br.readLine();
			}
		} catch (IOException e) {
			Utils.logErr(this.getClass(), "Couldn't find the file " + file.getAbsolutePath());
		}*/
	}

	private void generateOutputFiles(SymmariesHelper scsgHelper) throws TransformationException {
		writeAllMethsFile(scsgHelper);
		writeSecstubsFile(scsgHelper);
		// writeMethodsWithNosecsigs(scsgHelper);
		writeSourcesList(scsgHelper);
	}

	private void writeAllMethsFile(SymmariesHelper scsgHelper) {
		String meth_files = "";
		String targetDir = Utils.polishFilePath(configurations.outputPath// .replaceAll(BenchmarkExperimentConfig.outputFolderPath, "")
							);
		for (String method : scsgHelper.processedMethods)
			if (!configurations.excludedMathods.contains(method)) { // && !method.contains("dummyMainMethod"))
				meth_files += Utils.polishFilePath(targetDir + "/Meth/" + method + ".meth\n");
				// Utils.log(this.getClass(),"Exported the file " + "/Meth/" + method +
				// ".meth");
			}
		Utils.writeTextFile(configurations.outputPath + "/Meth/all.meth_files", meth_files);
		// Utils.log(this.getClass(), "Created the file /Meth/all.meth_files");
	}


	private void writeSourcesList(SymmariesHelper scsgHelper) {
		String sourcesList = "";
		for(SootMethod method: Scene.v().getEntryPoints()) {
			sourcesList  += getMethodUniqueName(method, method.getDeclaringClass().getName())+ "\n";
		}
		Utils.writeTextFile(configurations.outputPath + "/Meth/all." + Constants.srcsExtension, sourcesList);
	}

	private void writeMethodsWithNosecsigs(SymmariesHelper scsgHelper) throws TransformationException {
		String temp = Utils.readStringTextFile(configurations.outputPath + "/Misc/autoGeneratedSecsigs.txt") + "\n";
		this.methodsWithAutoGeneratedSecSignature.sort(new SootMethodsComparator());
		for(SootMethod method:methodsWithAutoGeneratedSecSignature) {
			String assumption = scsgHelper.constructHeader(method, true, SootUtilities.getClassName(method.getDeclaringClass()), new ArrayList<Value>());
			assumption +=  "{" + getLibrarySecurityAssumptions().get(method) + "}\n";
			if(!temp.contains(assumption)) {
				temp += assumption + "\n";
				//this.librarySecurityAssumptions.get().
			}
		}
		Utils.writeTextFile(this.configurations.outputPath + "/Misc/autoGeneratedSecsigs.txt", temp);

		temp = Utils.readStringTextFile(this.configurations.outputPath + "/Misc/noSecsigs.txt") + "\n";
		methodsWithNoSecSignature.sort(new SootMethodsComparator());
		for(SootMethod method:methodsWithNoSecSignature) {
			String assumption = scsgHelper.constructHeader(method, true, SootUtilities.getClassName(method.getDeclaringClass()), new ArrayList<Value>());
			assumption +=  "{" + getLibrarySecurityAssumptions().get(method) + "}\n";
			if(!temp.contains(assumption)) {
				temp += assumption + "\n";
				//this.librarySecurityAssumptions.get().
			}
		}
		Utils.writeTextFile(this.configurations.outputPath + "/Misc/noSecsigs.txt", temp);

	}

	private void writeSecstubsFile(SymmariesHelper scsgHelper) throws TransformationException {
		String secstubs = "";

		for (ArrayList<SecuritySignature> ssl: securitySignatures.values ())
			for (SecuritySignature ss: ssl)
				// if (!secstubs.contains(ss.header ()))
				secstubs += ss.toString ();

		for (SootMethod method : getSortedLibrarySecurityAssumptions()) {
			String assumption = scsgHelper.constructHeader(method, true, SootUtilities.getClassName(method.getDeclaringClass()), new ArrayList<Value>());
			if(!secstubs.contains(assumption)) {
				secstubs += assumption + "{";
				for(String tmp: getLibrarySecurityAssumptions().get(method))
					secstubs += tmp + ";";
				secstubs += "}\n";
			}
		}


		for (Type type : scsgHelper.dummyLowSinkMethodsList)
			secstubs += "static void " + Constants.dummyClass + ":" + Constants.lowSinkMethodName + "(" + type + "){-<~; output_⊥;}\n";
		for (Type type : scsgHelper.dummyHighSinkMethodsList)
			secstubs += "static void " + Constants.dummyClass + ":" + Constants.highSinkMethodName + "(" + type + "){-<~; @!;}\n";
		for (Type type : scsgHelper.dummyLowSourceMethodsList)
			secstubs += "static " + type + " " + Constants.dummyClass + ":" + Constants.lowSourceMethodName + "(){ -<~; return new_?}\n";
		for (Type type : scsgHelper.dummyHighSourceMethodsList)
			secstubs += "static " + type + " " + Constants.dummyClass + ":" + Constants.highSourceMethodName + "(){ -<~; return new_h }\n";
		Utils.writeTextFile(configurations.outputPath + java.io.File.separator + "Meth" +
				    java.io.File.separator + "all.secstubs", secstubs);
		// Utils.log(this.getClass(), "Created the file /Meth/all.secstubs");
	}

	public String getMethodUniqueName(SootMethod method, String declaringClass) {
		return (method.isConstructor() ? declaringClass : // SootUtilities.getClassName(method.getDeclaringClass()):
			declaringClass + // SootUtilities.getClassName(method.getDeclaringClass()) +
			// //(method.isConstructor()?"":
			"_" + escapeMethodName(method.getName()) + method.equivHashCode())
				.replaceAll("-", "");
	}

	public String getMethodUniqueNameV2(SootMethod method) {
		return SootUtilities.getClassName(method.getDeclaringClass()) + // (method.isConstructor()?"":
				"_" + escapeMethodName(method.getName());
	}

	private static String polishVarName(Value value) {
		String v = value.toString ();
		switch (v) {
		case "neg":
		case "cmp":
		case "cmpl":
		case "cmpg":
		case "checkpoint":
		case "monitorenter":
		case "output_t":
		case "output_T":
		case "output_l":
		case "output_L":
		case "exit":
			return v + "$$";
		default:
			return v;
		}
	}

	public String getSymmariesExpression(Value value, Value renameToThisVariable, TypeProcessor typeProcessor)
			throws TransformationException {
		// Value value = expression.getValue();
		if (SootUtilities.isLocalVariable(value))
			if (renameToThisVariable != null && renameToThisVariable.toString().equals(value.toString()))
				return "this";
			else
				return  polishVarName (value);
		if (SootUtilities.isParameterRef(value))
			return polishVarName(value);
		if (SootUtilities.isConstant(value))
			return value.toString();
		if (SootUtilities.isStaticField(value)) {
			staticFileds += SootUtilities.getClassName(((StaticFieldRef) value).getField().getDeclaringClass())
					.toString() + "\n";
			// throw new JimpleTransformationException (value + " is a static field. This
			// tool does not support static fields") ;
			return SootUtilities.getClassName(((StaticFieldRef) value).getField().getDeclaringClass()) + "."
			+ ((StaticFieldRef) value).getField().getName().toString();
		}
		if (SootUtilities.isFieldRef(value)) {
			return getSymmariesExpression(((FieldRef) value).getUseBoxes().get(0).getValue(), renameToThisVariable,
					typeProcessor)
					+ "."
					+ (((FieldRef) value).getField().getName().matches("[A-Z].*")
							? ((FieldRef) value).getField().getName()
									: ((FieldRef) value).getField().getName());
			// return ((FieldRef)value).getUseBoxes().get(0).getValue().toString() + "." +
			// ((FieldRef)value).getField().getName().toString();
		}
		if (SootUtilities.isCastExpr(value)) {
			JCastExpr expr = (JCastExpr) value;
			return "(" + escapeTypeName(expr.getType()) + ") "
			+ getSymmariesExpression(expr.getOp(), renameToThisVariable, typeProcessor);
		}

		if (value instanceof JNegExpr) {
			JNegExpr expr = (JNegExpr) value;
			return " ! (" + getSymmariesExpression(expr.getOp(), renameToThisVariable, typeProcessor) + ")";
		}

		if (value instanceof JAndExpr || value instanceof JOrExpr || value instanceof JDivExpr
				|| value instanceof JSubExpr || value instanceof JCmplExpr || value instanceof JMulExpr
				|| value instanceof JAddExpr || value instanceof JCmpExpr) {
			String op = (value instanceof JAndExpr ? " & "
					: (value instanceof JOrExpr ? " | "
							: (value instanceof JDivExpr ? "/"
									: (value instanceof JSubExpr ? "-"
											: (value instanceof JCmplExpr ? " cmpl "
													: (value instanceof JMulExpr ? " * "
															: (value instanceof JAddExpr ? "+"
																	: (value instanceof JCmpExpr ? " cmp " : ""))))))));
			typeProcessor.addsubtypeSupertypeRelation(((AbstractBinopExpr) value).getOp1().getType(),
					((AbstractBinopExpr) value).getOp2().getType());
			return "(" + getSymmariesExpression(((AbstractBinopExpr) value).getOp1(), renameToThisVariable, typeProcessor)
			+ op + getSymmariesExpression(((AbstractBinopExpr) value).getOp2(), renameToThisVariable, typeProcessor)
			+ ")";
		}
		if (value instanceof JLtExpr || value instanceof JLeExpr || value instanceof JNeExpr || value instanceof JGtExpr
				|| value instanceof JGeExpr || value instanceof JRemExpr || value instanceof JEqExpr
				|| value instanceof JUshrExpr || value instanceof JShrExpr || value instanceof JShlExpr
				|| value instanceof JCmpgExpr) {
			String op = (value instanceof JLtExpr ? "<"
					: (value instanceof JLeExpr ? "<="
							: (value instanceof JNeExpr ? "!="
									: (value instanceof JGtExpr ? ">"
											: (value instanceof JGeExpr ? ">="
													: (value instanceof JRemExpr ? "%"
															: (value instanceof JEqExpr ? "=="
																	: (value instanceof JUshrExpr ? ">>>"
																			: (value instanceof JShlExpr ? "<<"
																					: (value instanceof JShrExpr ? ">>"
																							: " cmpg "))))))))));
			typeProcessor.addsubtypeSupertypeRelation(((AbstractBinopExpr) value).getOp1().getType(),
					((AbstractBinopExpr) value).getOp2().getType());
			return "(" + getSymmariesExpression(((AbstractBinopExpr) value).getOp1(), renameToThisVariable, typeProcessor)
			+ op + getSymmariesExpression(((AbstractBinopExpr) value).getOp2(), renameToThisVariable, typeProcessor)
			+ ")";
		}
		if (value instanceof JArrayRef) {
			JArrayRef expr = (JArrayRef) value;
			return getSymmariesExpression(expr.getBase(), renameToThisVariable, typeProcessor) + "["
			+ getSymmariesExpression(expr.getIndex(), renameToThisVariable, typeProcessor) + "]";
		}
		if (value instanceof JNewArrayExpr) {
			JNewArrayExpr expr = (JNewArrayExpr) value;
			return "new " + expr.getBaseType() + "[" + getSymmariesExpression(expr.getSize(), renameToThisVariable, typeProcessor)  + "]";
		}
		if (value instanceof JLengthExpr)
			return "#" + getSymmariesExpression(((JLengthExpr) value).getOp(), renameToThisVariable, typeProcessor);
		if (value instanceof JInstanceOfExpr)
			return value.toString();
		if (value instanceof JXorExpr) {
			return "(!" + getSymmariesExpression(((JXorExpr) value).getOp1(), renameToThisVariable, typeProcessor) + " & "
					+ getSymmariesExpression(((JXorExpr) value).getOp2(), renameToThisVariable, typeProcessor) + ") |" + "(!"
					+ getSymmariesExpression(((JXorExpr) value).getOp2(), renameToThisVariable, typeProcessor) + " & "
					+ getSymmariesExpression(((JXorExpr) value).getOp1(), renameToThisVariable, typeProcessor) + ")";
		}

		if (SootUtilities.isConstant(value))
			return Constants.NIL;

		if (SootUtilities.isNullConstant(value))
			return value.toString();
		if (value instanceof ClassConstant) {
			return ((ClassConstant) value).toSootType().toString();// + "\"";
		}
		if (value instanceof JNewMultiArrayExpr) {
			//l4 = java.lang.String[3][5]
			JNewMultiArrayExpr expr = ((JNewMultiArrayExpr) value);
			String out = " new " + expr.getBaseType().baseType.toString();
			for(int i=0; i< expr.getSizeCount(); i++)
				out += "[" + getSymmariesExpression(expr.getSizeBox(i).getValue(),renameToThisVariable, typeProcessor) + "]";
			return out;
		}
		throw new TransformationException("Symmaries does not support expressions of type " +  value.getType());

		//		Utils.log(this.getClass(), value.toString());
		//		return "";
	}

	public void loadAssumedSecuritySignatures() {
		if(configurations.assumedSecSigsFilePath==null ||
		   configurations.assumedSecSigsFilePath.length == 0) {
			Utils.log(getClass(), "The security stubs file is missing." );
			return;
		}
		for(String fileName:configurations.assumedSecSigsFilePath) {
			File file = new File(fileName);
			if(!file.exists()) {
				Utils.log(getClass(), "The security stubs file " + file.getAbsolutePath() + " does not exist." );
				continue;
			}
			Utils.log(getClass(), "Loading security stubs file " + file.getAbsolutePath());
			BufferedReader br;
			try {
				br = new BufferedReader(new FileReader(file));
				String line = br.readLine();
				while (line != null) {
					String l = line.trim ();
					if (!l.equals("") && !l.startsWith("//")) {
						SecuritySignature securitySignature = new SecuritySignature();
						if (securitySignature.extractSecuritySigntaure(l)) {
							if (securitySignatures.get(securitySignature.method) == null)
								securitySignatures.put(securitySignature.method, new ArrayList<SecuritySignature>());
							securitySignatures.get(securitySignature.method).add(securitySignature);
						}
					}
					line = br.readLine();
				}
			} catch (IOException e) {
				Utils.logErr(this.getClass(), "Couldn't find the file " + file.getAbsolutePath());
			}
		}
	}

	public LinkedHashMap<SootMethod, ArrayList<String>> getLibrarySecurityAssumptions() {
		return librarySecurityAssumptions;
	}

	public class SootMethodsComparator implements Comparator {
		@Override
		public int compare(Object o1, Object o2) {
			if(((SootMethod)o1).isJavaLibraryMethod() &&
					!((SootMethod)o2).isJavaLibraryMethod())
				return 1;
			else
				if(((SootMethod)o2).isJavaLibraryMethod() &&
						!((SootMethod)o1).isJavaLibraryMethod())
					return -1;
				else
					return (((SootMethod)o1).getDeclaringClass().getName()+((SootMethod)o1).getName()).compareTo
							(((SootMethod)o2).getDeclaringClass().getName()+((SootMethod)o2).getName());
		}
	}

	public List<SootMethod> getSortedLibrarySecurityAssumptions() {
		List<SootMethod> sortedKeys = new ArrayList<SootMethod>();
		sortedKeys.addAll(librarySecurityAssumptions.keySet());
		Collections.sort(sortedKeys, new SootMethodsComparator());
		return sortedKeys;
	}


	public void setLibrarySecurityAssumptions(LinkedHashMap<SootMethod, ArrayList<String>> librarySecurityAssumptions) {
		this.librarySecurityAssumptions = librarySecurityAssumptions;
	}

	public void extractSourceSinkFromXML() {
		sourceSinkHelper= new SourceSinkHelper();
		XMLSourceSinkParser xmlParser = new XMLSourceSinkParser();
		if(xmlParser.readXMLFile(configurations.xmlSourcesAndSinks)) {
			Utils.log(getClass(),"Processing the xml file " + configurations.xmlSourcesAndSinks);
			xmlParser.getAllSinksOrSources(sourceSinkHelper.highSources, true,true);
			xmlParser.getAllSinksOrSources(sourceSinkHelper.highSinks, true,false);
			xmlParser.getAllSinksOrSources(sourceSinkHelper.lowSources, false,true);
			xmlParser.getAllSinksOrSources(sourceSinkHelper.lowSinks, false,false);
		}
		if(sourceSinkHelper.highSources.isEmpty())
			Utils.log(getClass(), "The application has NO high source!");
		if(sourceSinkHelper.lowSources.isEmpty())
			Utils.log(getClass(), "The application has NO low source!");
		if(sourceSinkHelper.highSinks.isEmpty())
			Utils.log(getClass(), "The application has NO high sink!");
		if(sourceSinkHelper.lowSinks.isEmpty())
			Utils.log(getClass(), "The application has NO low sink!");
	}

	public void loadSecstubsFromXMLFile() {
		XMLSecstubsParser xmlParser = new XMLSecstubsParser();
		if(xmlParser.readXMLFile(configurations.xmlSecsstubsPath)) {
			xmlParser.getSecstubs(securitySignatures);
		}
	}

	/*
	 *
			secstubs += "void " + Constants.dummyClass + ":" + Constants.lowSinkMethodName + "(" + type + "){output_⊥;}\n";
		for (Type type : scsgHelper.dummyHighSinkMethodsList)
			secstubs += "void " + Constants.dummyClass + ":" + Constants.highSinkMethodName + "(" + type + "){@!;}\n";
		for (Type type : scsgHelper.dummyLowSourceMethodsList)
			secstubs += type + " " + Constants.dummyClass + ":" + Constants.lowSourceMethodName + "(){ -<~; return new_?}\n";
		for (Type type : scsgHelper.dummyHighSourceMethodsList)
			secstubs += type + " " + Constants.dummyClass + ":" + Constants.highSourceMethodName + "(){ -<~; return .*h }\n";

	 */

	public void extractSourceSinksFromSecuritySignatures() {
		if(this.sourceSinkHelper.lowSinks.get(Utils.XMlMethod)==null)
			this.sourceSinkHelper.lowSinks.put((String)Utils.XMlMethod, new ArrayList());
		if(this.sourceSinkHelper.highSinks.get(Utils.XMlMethod)==null)
			this.sourceSinkHelper.highSinks.put((String)Utils.XMlMethod, new ArrayList());
		if(this.sourceSinkHelper.lowSources.get(Utils.XMlMethod)==null)
			this.sourceSinkHelper.lowSources.put((String)Utils.XMlMethod, new ArrayList());
		if(this.sourceSinkHelper.highSources.get(Utils.XMlMethod)==null)
			this.sourceSinkHelper.highSources.put((String)Utils.XMlMethod, new ArrayList());
		for(String method: this.securitySignatures.keySet()) {
			List<SecuritySignature> signatures = securitySignatures.get(method);
			for(SecuritySignature sig : signatures) {
				if (sig.secSignature.contains("return .*h"))
					this.sourceSinkHelper.highSources.get(Utils.XMlMethod).add(new String[] {"L" + sig.className.replaceAll("\\.", "/"), sig.method});

				if (sig.secSignature.contains("output_l"))
					this.sourceSinkHelper.lowSinks.get(Utils.XMlMethod).add(new String[] {"L" + sig.className.replaceAll("\\.", "/"), sig.method});

				if (sig.secSignature.contains("@!"))
					this.sourceSinkHelper.highSinks.get(Utils.XMlMethod).add(new String[] {"L" + sig.className.replaceAll("\\.", "/"), sig.method});

				if (sig.secSignature.contains("return new_?"))
					this.sourceSinkHelper.lowSources.get(Utils.XMlMethod).add(new String[] {"L" + sig.className.replaceAll("\\.", "/"), sig.method});

			}
		}
	}

	public void clear() {
		this.librarySecurityAssumptions.clear();
		this.methodsWithAutoGeneratedSecSignature.clear();
		this.methodsWithNoSecSignature.clear();
		this.securitySignatures.clear();
		this.sourceSinkHelper.highSinks.clear();
		this.sourceSinkHelper.lowSinks.clear();
		this.sourceSinkHelper.highSources.clear();
		this.sourceSinkHelper.lowSources.clear();
		this.staticFileds = "";
	}
}
